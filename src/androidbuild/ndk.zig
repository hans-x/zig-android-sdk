const std = @import("std");
const Compile = std.Build.Step.Compile;
const LazyPath = std.Build.LazyPath;
const Apk = @import("apk.zig");

pub fn applyNDK(b: *std.Build, artifact: *Compile, apk: *const Apk) void {
    artifact.linkLibC();

    const system_target = getAndroidTriple(artifact.rootModuleTarget()) catch |err| @panic(@errorName(err));

    const android_api_version: u32 = @intFromEnum(apk.api_level);

    const libc = createLibC(b, system_target, android_api_version, apk.ndk.sysroot_path, apk.ndk.version);

    const library_path1: LazyPath = .{ .cwd_relative = b.fmt("{s}/usr/lib/{s}/{d}", .{ apk.ndk.sysroot_path, system_target, android_api_version }) };
    const library_path2: LazyPath = .{ .cwd_relative = b.fmt("{s}/usr/lib/{s}", .{ apk.ndk.sysroot_path, system_target }) };
    setArtifactNDK(artifact, libc, library_path1, library_path2);
}

fn createLibC(b: *std.Build, system_target: []const u8, android_api_version: u32, ndk_sysroot_path: []const u8, ndk_version: []const u8) std.Build.LazyPath {
    const libc_file_format =
        \\# Generated by zig-android-sdk. DO NOT EDIT.
        \\
        \\# The directory that contains `stdlib.h`.
        \\# On POSIX-like systems, include directories be found with: `cc -E -Wp,-v -xc /dev/null`
        \\include_dir={[include_dir]s}
        \\
        \\# The system-specific include directory. May be the same as `include_dir`.
        \\# On Windows it's the directory that includes `vcruntime.h`.
        \\# On POSIX it's the directory that includes `sys/errno.h`.
        \\sys_include_dir={[sys_include_dir]s}
        \\
        \\# The directory that contains `crt1.o`.
        \\# On POSIX, can be found with `cc -print-file-name=crt1.o`.
        \\# Not needed when targeting MacOS.
        \\crt_dir={[crt_dir]s}
        \\
        \\# The directory that contains `vcruntime.lib`.
        \\# Only needed when targeting MSVC on Windows.
        \\msvc_lib_dir=
        \\
        \\# The directory that contains `kernel32.lib`.
        \\# Only needed when targeting MSVC on Windows.
        \\kernel32_lib_dir=
        \\
        \\gcc_dir=
    ;

    const include_dir = b.fmt("{s}/usr/include", .{ndk_sysroot_path});
    const sys_include_dir = b.fmt("{s}/usr/include/{s}", .{ ndk_sysroot_path, system_target });
    const crt_dir = b.fmt("{s}/usr/lib/{s}/{d}", .{ ndk_sysroot_path, system_target, android_api_version });

    const libc_file_contents = b.fmt(libc_file_format, .{
        .include_dir = include_dir,
        .sys_include_dir = sys_include_dir,
        .crt_dir = crt_dir,
    });

    const filename = b.fmt("android-libc_target-{s}_version-{d}_ndk-{s}.conf", .{ system_target, android_api_version, if (ndk_version.len > 0) ndk_version else "unknown" });

    const write_file = b.addWriteFiles();
    const android_libc_path = write_file.add(filename, libc_file_contents);
    return android_libc_path;
}

fn getAndroidTriple(target: std.Target) error{InvalidAndroidTarget}![]const u8 {
    if (target.abi != .android) return error.InvalidAndroidTarget;
    return switch (target.cpu.arch) {
        .x86 => "i686-linux-android",
        .x86_64 => "x86_64-linux-android",
        .arm => "arm-linux-androideabi",
        .aarch64 => "aarch64-linux-android",
        .riscv64 => "riscv64-linux-android",
        else => error.InvalidAndroidTarget,
    };
}

fn setArtifactNDK(artifact: *Compile, libc_file: LazyPath, library_path1: LazyPath, library_path2: LazyPath) void {
    artifact.setLibCFile(libc_file);
    libc_file.addStepDependencies(&artifact.step);
    setNDK(artifact.root_module, libc_file, library_path1, library_path2);
}

fn setNDK(root_module: *std.Build.Module, libc_file: LazyPath, library_path1: LazyPath, library_path2: LazyPath) void {
    root_module.addLibraryPath(library_path1);
    root_module.addLibraryPath(library_path2);

    iterateLinkObjects(root_module.link_objects, libc_file, library_path1, library_path2);

    var imported_it = root_module.import_table.iterator();
    while (imported_it.next()) |entry| {
        const imported = entry.value_ptr.*;
        setNDK(imported, libc_file, library_path1, library_path2);
    }
}

fn iterateLinkObjects(link_objects: std.ArrayListUnmanaged(std.Build.Module.LinkObject), libc_file: LazyPath, library_path1: LazyPath, library_path2: LazyPath) void {
    for (link_objects.items) |link_object| {
        switch (link_object) {
            .other_step => |artifact| {
                switch (artifact.kind) {
                    .lib => {
                        const link_libc = artifact.root_module.link_libc orelse false;
                        const link_libcpp = artifact.root_module.link_libcpp orelse false;

                        if (link_libc or link_libcpp) {
                            setArtifactNDK(artifact, libc_file, library_path1, library_path2);
                        }
                    },
                    else => continue,
                }
            },
            else => {},
        }
    }
}
